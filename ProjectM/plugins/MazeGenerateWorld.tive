using System;
using System.Collections.Generic;
using System.Text;
using System.Threading.Tasks;
using ProdigalSoftware.TiVEPluginFramework;

namespace ProdigalSoftware.ProjectM.Plugins
{
    public class GenerateMazeWorld : IWorldGenerator
    {
        private const int Front = 1;
        private const int Back = 2;
        private const int Left = 4;
        private const int Right = 8;
        private const int Top = 16;
        private const int Bottom = 32;

        public string BlockListForWorld(string gameWorldName)
        {
            return gameWorldName == "Maze" ? "maze" : null;
        }
        
        public GameWorld CreateGameWorld(string gameWorldName, IBlockList blockList)
        {
            if (gameWorldName != "Maze")
                return null;

            GameWorld gameWorld = new GameWorld(150, 150, 8);
            gameWorld.LightingModelType = LightingModelType.Realistic;
            FillWorld(gameWorld, blockList);
            SmoothWorld(gameWorld, blockList);

            return gameWorld;
        }

        private static void SmoothWorld(GameWorld gameWorld, IBlockList blockList)
        {
            for (int z = 0; z < gameWorld.BlockSize.Z; z++)
            {
                for (int x = 0; x < gameWorld.BlockSize.X; x++)
                {
                    for (int y = 0; y < gameWorld.BlockSize.Y; y++)
                    {
                        ushort blockIndex = gameWorld[x, y, z];
                        if (blockIndex == 0)
                            continue;

                        BlockInformation block = blockList[blockIndex];
                        string blockNameKey = GetBlockSet(block);

                        if (blockNameKey != "ston" && blockNameKey != "sand" && blockNameKey != "lava")
                            continue;

                        int sides = 0;

                        if (z == 0 || gameWorld[x, y, z - 1] == 0)
                            sides |= Back;

                        if (z == gameWorld.BlockSize.Z - 1 || gameWorld[x, y, z + 1] == 0)
                            sides |= Front;

                        if (x == 0 || gameWorld[x - 1, y, z] == 0)
                            sides |= Left;

                        if (x == gameWorld.BlockSize.X - 1 || gameWorld[x + 1, y, z] == 0)
                            sides |= Right;

                        if (y == 0 || gameWorld[x, y - 1, z] == 0)
                            sides |= Bottom;

                        if (y == gameWorld.BlockSize.Y - 1 || gameWorld[x, y + 1, z] == 0)
                            sides |= Top;

                        gameWorld[x, y, z] = blockList[blockNameKey + sides];
                    }
                }
            }
        }

        private static void FillWorld(GameWorld gameWorld, IBlockList blockList)
        {
            BlockRandomizer backWalls = new BlockRandomizer(blockList, "back", 5);
            ushort stone = blockList["ston0"];
            ushort light = blockList["light0"];

            for (int x = 0; x < gameWorld.BlockSize.X; x++)
            {
                for (int y = 0; y < gameWorld.BlockSize.Y; y++)
                {
                    gameWorld[x, y, 0] = backWalls.NextBlock();
                    gameWorld[x, y, 1] = stone;
                    gameWorld[x, y, 2] = stone;
                    gameWorld[x, y, 3] = stone;
                    gameWorld[x, y, 4] = stone;
                    gameWorld[x, y, 5] = stone;
                }
            }
            
            ushort sand = blockList["sand0"];
            ushort fire = blockList["fire"];
            ushort lava = blockList["lava0"];
            ushort fountain = blockList["fountain"];

            Random random = new Random();

            int xLoc = random.Next(gameWorld.BlockSize.X - 6) + 3;
            int yLoc = random.Next(gameWorld.BlockSize.Y - 6) + 3;

            for (int i = 0; i < 10000; i++)
            {
                bool moved = false;
                do
                {
                    switch (random.Next(4))
                    {
                        case 0:
                            if (xLoc < gameWorld.BlockSize.X - 3)
                            {
                                xLoc++;
                                moved = true;
                            }
                            break;
                        case 1:
                            if (yLoc < gameWorld.BlockSize.Y - 3)
                            {
                                yLoc++;
                                moved = true;
                            }
                            break;
                        case 2:
                            if (xLoc > 2)
                            {
                                xLoc--;
                                moved = true;
                            }
                            break;
                        case 3:
                            if (yLoc > 2)
                            {
                                yLoc--;
                                moved = true;
                            }
                            break;
                    }
                }
                while (!moved);

                for (int z = 1; z < 8; z++)
                {
                    gameWorld[xLoc - 1, yLoc - 1, z] = 0;
                    gameWorld[xLoc, yLoc - 1, z] = 0;
                    gameWorld[xLoc + 1, yLoc - 1, z] = 0;
                    gameWorld[xLoc - 1, yLoc, z] = 0;
                    gameWorld[xLoc, yLoc, z] = 0;
                    gameWorld[xLoc + 1, yLoc, z] = 0;
                    gameWorld[xLoc - 1, yLoc + 1, z] = 0;
                    gameWorld[xLoc, yLoc + 1, z] = 0;
                    gameWorld[xLoc + 1, yLoc + 1, z] = 0;
                }
            }
        }

        private static string GetBlockSet(BlockInformation block)
        {
            return block.BlockName.Substring(0, 4);
        }

        private static void Fill(GameWorld gameWorld, int x, int y, ref int depth, BlockRandomizer block)
        {
            for (int i = 0; i < 3; i++)
                gameWorld[x, y, depth++] = block.NextBlock();
        }

        private static void Fill(GameWorld gameWorld, int x, int y, ref int depth, ushort block)
        {
            for (int i = 0; i < 3; i++)
                gameWorld[x, y, depth++] = block;
        }

        #region BlockRandomizer class
        private sealed class BlockRandomizer
        {
            public readonly ushort[] Blocks;
            private readonly Random random = new Random();

            public BlockRandomizer(IBlockList blockList, string blockname, int blockCount)
            {
                Blocks = new ushort[blockCount];
                for (int i = 0; i < Blocks.Length; i++)
                    Blocks[i] = blockList[blockname + i];
            }

            public ushort NextBlock()
            {
                int blockNum = random.Next(Blocks.Length);
                return Blocks[blockNum];
                //return Blocks[Blocks.Length - 1];
            }
        }
        #endregion
    }
}
